# 候选人追踪：双堆

代码：
```python
import sys
import heapq
lines = sys.stdin.read().splitlines()
m,k = map(int,lines[0].split())
N = 314159
votes = []
line2 = lines[1].split()
for i in range(m):
    time,candidate = map(int,line2[2*i:2*i+2])
    votes.append([time,candidate-1])
votes = sorted(votes)
chosen = set([int(_)-1 for _ in lines[2].split()])
unchosen = set(list(range(N))) - chosen

minheap = [(0,i) for i in chosen] # chosen candidates
maxheap = [(0,i) for i in unchosen] # unchosen candidates
record = [0]*N #linear record

#print(record)
#print(chosen)
#print(unchosen)

total_time = 0

def clear_top():
    while minheap and record[minheap[0][1]] > minheap[0][0]:
        heapq.heappop(minheap)
    while maxheap and record[maxheap[0][1]] > -maxheap[0][0]:
        heapq.heappop(maxheap)

if not (minheap and maxheap) or (minheap[0][0] > (-maxheap[0][0])):
    total_time += votes[0][0]

for idx,vote in enumerate(votes):
    time,candidate = vote
    flag = not (minheap and maxheap) or (minheap[0][0] > (-maxheap[0][0]))
    if idx and flag:
        total_time += time - votes[idx - 1][0]
    record[candidate] += 1
    
    # each update is pushed into the heap, so we don't have to push when clearing the top
    if candidate in chosen:
        heapq.heappush(minheap,(record[candidate],candidate))
    else:
        heapq.heappush(maxheap,(-record[candidate],candidate))
    
    clear_top()
    
    # print(f'idx = {idx} t = {time} record = {record} flag before = {flag} minheap = {minheap} maxheap = {maxheap}')

print(total_time)
```

## 注意点：

#### 1.更新策略
每次更新的时候，把**更新信息**入堆；每次查看堆顶之前要**清理堆顶**。如果采用**不入堆**而**在清理的时候再把更新后的信息入堆**的话，会出现问题——比如如果堆顶和你的元素大小相同，那么此时你不会去入堆——因为堆顶那一个元素是正确的，但是实际上由于你的元素更新了，导致堆顶实际上应该更新为你的元素，于是就会出现错误

#### 2.空堆警告⚠
如果说追踪的是全体，那么`maxheap`就是空堆了。不能查看空堆的堆顶！因此每次遇到此类问题都需要事先判断堆是不是空的

#### 3.t=0时刻处理⚠
大部分情况下t=0时刻是不满足条件的，除了`chosen={}`或`unchosen={}`这两种情况。所以这一段时间得特殊处理

#### 4.n是投票信息而非总人数！总人数为314159！！！⚠⚠⚠
