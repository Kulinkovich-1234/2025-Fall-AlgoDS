## E30061:春游集合

[OpenJudge - E30061:春游集合](http://cs101.openjudge.cn/cs1012025feclass11/E30061/)

描述

老师带领同学们春游。已知班上有 N 位同学，每位同学有从 0 到 N−1 的唯一编号。到了集合时间，老师确认是否所有同学都到达了集合地点，就让同学们报出自己的编号。到达的同学都会报出自己的编号，不会报出别人的编号，但有的同学很顽皮，会多次报出。你能帮老师找出有哪些同学没有到达吗?

输入

输入包含 2 行。第一行包含两个整数 N 和 M，表示班级有 N 位同学，同学们共有 M 次报出编号。约定 2 ≤ N,M ≤ 1000。  
第二行包含 M 个整数，分别为 M 次报出的编号。约定所有编号是小于 N 的非负整数。

输出

输出一行。如果所有同学都到达，则输出 N；否则由小到大输出所有未到达的同学编号，空格分隔。

```python
n,m = map(int,input().split())
arr = set([int(_) for _ in input().split()])
narr = set(list(range(n))) - arr
if len(narr) == 0:
    print(n)
else:
    l = sorted(list(narr))
    print(*l)
```

---

## E30085:纪念品分组

[OpenJudge - E30085:纪念品分组](http://cs101.openjudge.cn/cs1012025feclass11/E30085/)

描述

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。

你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

输入

共 n+2 行：  
  
第一行包括一个整数 w，80 ≤ w ≤ 200，为每组纪念品价格之和的上限。  
  
第二行为一个整数 n，1 ≤ n ≤ 3×10^4，表示购来的纪念品的总件数。  
  
第 3∼n+2 行每行包含一个正整数 Pi，5 ≤Pi ≤ w。表示所对应纪念品的价格。

输出

一个整数，即最少的分组数目。

```python
from bisect import *
w = int(input())
n = int(input())
gift = []
for i in range(n):
    gift.append(int(input()))
gift = sorted(gift)
used = [False] * n
idx = n-1
groups = 0
while idx >= 0:
    left = w - gift[idx]
    used[idx] = True
    jdx = bisect_right(gift,left)
    groups += 1
    found = False
    while jdx >= 0:
        if not used[jdx] and gift[jdx] <= left:
            found = True
            break
        jdx -= 1
    if found:
        used[jdx] = True
    
    while idx >= 0 and used[idx]:
        idx -= 1
print(groups)
```

---

## M30062:非递减子序列

[OpenJudge - M30062:非递减子序列](http://cs101.openjudge.cn/cs1012025feclass11/M30062/)

描述

给你一个整数数组 `nums` ，找出所有该数组中 **不同的** 非递减子序列，并输出 **总数量**，非递减子序列中 **至少有两个元素** 。

数组中可能含有重复元素，如出现两个整数相等，也可以视作 非递减序列 的一种情况。

`1 ≤ nums.length ≤ 15`，`-100 ≤ nums[i] ≤ 100`

输入

一行整数，表示整数数组 nums 中的元素。

输出

一个整数，表示所有该数组中不同的非递减子序列的总数量。

```python
nums = list(map(int,input().split()))
n = len(nums)
ans = set()
def search(pos,prev):
    if len(prev) > 2:
        ans.add(tuple(prev))
    if pos >= n:
        return
    for i in range(pos,n):
        if prev[-1] <= nums[i]:
            search(i+1,prev+[nums[i]])

search(0,[-1e9])
#print(list(ans))
print(len(ans))
```

---

## M30216:赦免战俘

[OpenJudge - E30061:春游集合](http://cs101.openjudge.cn/cs1012025feclass11/E30061/)

描述

借助反作弊系统，一些在比赛有抄袭作弊行为的选手被抓出来了！现有 2n×2n (n ≤ 10) 名作弊者站成一个正方形方阵等候发落。官方决定赦免一些作弊者，他们将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被惩罚。

给出 n，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。

输入

一个整数 n。

输出

2^n × 2^n 的 01 矩阵，代表每个人是否被赦免。数字之间有一个空格。

```python
n = int(input())
N = 2**n
mask = N - 1
mapp = [[1]*N for _ in range(N)]
for i in range(N):
    for j in range(N):
        if (i^mask) & (j ^ mask):
            mapp[i][j] = 0
for line in mapp:
    print(' '.join([str(x) for x in line]))
```

思路：

通过观察可以发现，一个位置 `(i, j)` 被赦免（即输出 0）的条件是：在二进制表示下，行号 `i` 和列号 `j` 至少存在一个相同的二进制位均为 0。这是因为每次划分时，**左上角矩阵的行和列**在当前对应的二进制位上都是 0，只要某个位置**在任意一次划分中属于左上角矩阵**，它就会被赦免。

利用位运算可以高效判断。令 $N = 2^n$，$\mathrm{mask} = N - 1$（即二进制下 n 个 1）。对于每个位置 `(i, j)`，计算 `(i ^ mask) & (j ^ mask)`，若结果不为 0，说明 i 和 j 在二进制下至少有一位同时为 0（因为异或 `mask` 相当于按位取反，再按位与不为 0 意味着取反前至少有一位同时为 1，即原数的对应位同时为 0），则该位置被赦免，置为 0；否则置为 1。

这种方法避免了递归分治，直接通过遍历矩阵和位运算完成，时间复杂度为 O(N²)，在 n ≤ 10 的范围内运行效率很高。最后逐行输出矩阵即可。

等价的表达式也可以是`(i | j) != (1 << N) - 1`

---

## M30442:上课赶时间

[OpenJudge - M30442:上课赶时间](http://cs101.openjudge.cn/cs1012025feclass11/M30442/)

描述

Blackslex 要迟到了！为了赶去上课，Blackslex 必须按特定顺序乘坐拥挤的电梯经过多个楼层。由于他是个黑客，他最多可以跳过其中一层楼而不被其他人发现。他所花的时间等于相邻楼层编号之差的绝对值之和。现在，请你找出在他最多跳过一层楼的前提下，所需的最短时间。

更形式化地说，给定一个包含 n 个整数的数组 `a = [a1, a2, ..., an]` ，你可以选择最多一个下标 `k ∈‌ {1, 2, ..., n}` 将其删除，使得删除后的数组 `b = [a1, ..., ak-1, ak+1, ..., an]` 满足以下总和最小：
$$
\sum_{i=1}^{n-2}|b_i-b_{i+1}|
$$

请输出这个最小的总和。

输入

第一行包含一个整数 t (1 ≤ t ≤ 10^4 )—— 测试用例的数量。  
  
每个测试用例的第一行包含一个整数 n (3 ≤ n ≤ 2*10^5)—— 数组的大小。  
  
第二行包含 n 个整数 a1, a2, ..., an ( 1 ≤ ai ≤ 100 )。  
  
保证所有测试用例中 n 的总和不超过 `2*10^5`。

输出

对每个测试用例，输出一个整数—— 所需的最短时间。

```python
t = int(input())
for _ in range(t):
    n = int(input())
    a = list(map(int,input().split()))
    original_cost = 0
    for i in range(1,n):
        original_cost += abs(a[i] - a[i-1])
    shortcut = [0] * n
    shortcut[0] = -abs(a[0]-a[1])
    shortcut[n-1] = -abs(a[n-2]-a[n-1])
    for i in range(1,n-1):
        shortcut[i] = abs(a[i-1]-a[i+1]) - (abs(a[i-1]-a[i]) + abs(a[i]-a[i+1]))
    #print('ori=',original_cost,'shortcut = ',shortcut)
    print(original_cost + min(shortcut))
```

---

## T30220:星际贸易航线

[OpenJudge - T30220:星际贸易航线](http://cs101.openjudge.cn/cs1012025feclass11/T30220/)

描述

你是一艘星际货船的船长，正执行一项从银河系边缘前往核心星区的长途运输任务。

星图被表示为一个 N 行 M 列的网格。你的旅程从左上角 (1, 1) 开始，终点是右下角 (N, M)。为了利用引力弹弓效应节省燃料，你在每一步只能向右或向下移动。

网格中的每个区域都有一个数值，代表经过该区域时的航行结果：

- **正数**：表示安全的贸易区，你可通过货物交易获得收益。
- **负数**：表示危险区域（例如小行星带或海盗出没区），会导致船体损伤或燃料泄漏，从而造成损失（即资金扣除）。

你的飞船配备了一套实验性的“暗物质偏转护盾”。在整个航程中，你可以选择在**恰好一个**危险区域（负值格子）上激活该护盾。护盾不仅能完全吸收伤害，还能将冲击能量转化为辅助推进力，使原本的损失转变为等量的收益（即数值 x 变为 -x；例如，-100 的损失会变成 +100 的收益）。注意：如果你规划的路径全部由正数组成，则你**不能也不需要**使用护盾。

请规划一条航线，并策略性地使用护盾，使得抵达目的地时获得的**总净收益最大**。

输入

第一行包含两个整数 N 和 M，1 ≤ N, M ≤ 500。  
  
接下来的 N 行，每行包含 M 个整数，表示网格中每个区域的收益或损失值。  
网格中的数值范围为 [−100, 100]。

输出

输出一个整数，表示所能获得的最大总净收益。

```python
n,m = map(int,input().split())
inf = float('inf')
mapp = []
for i in range(n):
    mapp.append([int(_) for _ in input().split()])
dp = [[[-inf,-inf] for j in range(m)] for i in range(n)]
def judge(x,y):
    return 0 <= x < n and 0 <= y < m
dp[0][0][0] = mapp[0][0]
dp[0][0][1] = -mapp[0][0]
for i in range(n):
    for j in range(m):
        if judge(i-1,j):
            dp[i][j][0] = max(dp[i][j][0],dp[i-1][j][0] + mapp[i][j])
            dp[i][j][1] = max(dp[i][j][1],dp[i-1][j][1] + mapp[i][j],dp[i-1][j][0] - mapp[i][j])
        if judge(i,j-1):
            dp[i][j][0] = max(dp[i][j][0],dp[i][j-1][0] + mapp[i][j])
            dp[i][j][1] = max(dp[i][j][1],dp[i][j-1][1] + mapp[i][j],dp[i][j-1][0] - mapp[i][j])
print(max(dp[n-1][m-1]))
```

思路：二重dp，`dp[x][y][0]`表示没有使用过护盾的最大收益，`dp[x][y][1]`表示使用过护盾的最大收益

略微优化版本：

```python
n,m = map(int,input().split())
inf = float('inf')
mapp = []
for i in range(n):
    mapp.append([int(_) for _ in input().split()])

dp = [[[-inf,-inf] for j in range(m)] for i in range(n)]
dp[0][0][0] = mapp[0][0]
dp[0][0][1] = -mapp[0][0]
dprev = [[-1,0],[0,-1]]


def judge(x,y):
    return 0 <= x < n and 0 <= y < m

for i in range(n):
    for j in range(m):
	    for dx,dy in dprev:
		    prevx,prevy = i + dx,j + dy
		    if not judge(prevx,prevy):
			    continue
			prev = dp[prevx][prevy]
			now = dp[i][j]
			now[0] = max(now[0],prev[0] + mapp[i][j])
            now[1] = max(now[1],prev[1] + mapp[i][j],prev[0] - mapp[i][j])    

print(max(dp[n-1][m-1]))
```
---

